<!DOCTYPE html>
<html>
	<head lang="en">
		<meta charset="utf-8">
		<title>Factory</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js" integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz" crossorigin="anonymous"></script>
        <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
        

        <script type="importmap">
          {
            "imports": {
              "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
              "three_mmi": "./three_mmi.js",
              "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
            }
          }
        </script>
	</head>
  
	<body>

    <canvas class="webgl" width="1000" height="400" style="border:1px solid rgb(0, 238, 40);"></canvas>
    <script type="module" src="animation.js"></script>   
    <script src="logic.js"></script> 

        <div class="container text-center">
            
              <div class="row">
              <div class="col-sm">
                  <!-- input field bottom left -->
                <div class="input-box">
                    <h3>Product Details</h3>
            
                    <div class="input-group flex-nowrap">
                        <span class="input-group-text" >ProductID</span>
                        <input type="text" class="form-control"  id="ProductID" >
                      </div>
            
                      <div class="input-group flex-nowrap">
                        <span class="input-group-text" >Temperature</span>
                        <input type="text" class="form-control"  id="Temperature">
                      </div>
            
                      <div class="input-group flex-nowrap">
                        <span class="input-group-text" >Weight</span>
                        <input type="text" class="form-control"  id="Weight">
                      </div>
            
                      <div class="input-group flex-nowrap">
                        <span class="input-group-text" >Quantity</span>
                        <input type="text" class="form-control"  id="Quality">
                      </div>
            
                      <div class="input-group flex-nowrap">
                        <span class="input-group-text" >Dimentions</span>
                        <input type="text" class="form-control"  id="Dimentions">
                      </div>
                    <br>
                    <button type="button" class="btn btn-primary" id="submitFields">Submit</button>
                </div>
              </div>
              <div class="col-sm">
                <div>
                    <h3>Check Stages</h3>
                    <!-- Stage field bottom middle -->
                  <div class="input-group mb-3">
                      <button class="btn btn-outline-primary" type="button" id="stage1" >Stage 1</button>
                      <input type="text" class="form-control" placeholder="Temperature" id="stage1value">
                    </div>
                    <div class="input-group mb-3">
                      <button class="btn btn-outline-primary" type="button" id="stage2" >Stage 2</button>
                      <input type="text" class="form-control" placeholder="Weight" id="stage2value">
                    </div>
                    <div class="input-group mb-3">
                      <button class="btn btn-outline-primary" type="button" id="stage3" >Stage 3</button>
                      <input type="text" class="form-control" placeholder="Quality" id="stage3value">
                    </div>
                    <div class="input-group mb-3">
                      <button class="btn btn-outline-primary" type="button" id="stage4" >Stage 4</button>
                      <input type="text" class="form-control" placeholder="Dimentions" id="stage4value">
                    </div>
                </div>
            </div>
            <script src="logic.js"></script>
              <div class="col-sm" >
                  <div style="align-items: center;">
                      <!-- Results -->
                      <h3>View Results</h3>
                    <div style="padding-bottom: 16px;" id="resultdiv">
                        <input type="text" id="stage1Res" class="btn btn-outline-success">
                    </div>
                    <div style="padding-bottom: 16px;">
                        <input type="text" id="stage2Res" class="btn btn-outline-success">
                    </div>
                    <div style="padding-bottom: 16px;">
                        <input type="text" id="stage3Res" class="btn btn-outline-success">
                    </div>
                    <div style="padding-bottom: 16px;">
                        <input type="text" id="stage4Res" class="btn btn-outline-success">
                    </div>
                  </div>
              </div>
            </div> 
        </div>
	</body>
</html>


<!-- animation.js -->

import * as THREE from 'three'
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import {OrbitControls} from 'https://unpkg.com/three@0.154.0/examples/jsm/controls/OrbitControls.js'
import MouseMeshInteraction from 'three_mmi'

console.log(THREE)

const canvas = document.querySelector(".webgl");

//set sizes
const sizes={
  width : canvas.width,
  height : canvas.height
}

//renderer
 const renderer = new THREE.WebGLRenderer(
  {
      antialias:true,
      canvas : canvas
  }
)
renderer.setSize(sizes.width,sizes.height)
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))
renderer.shadowMap.enabled =true
renderer.gammaOutput=true



//set Scene
const scene =new THREE.Scene()
scene.background=new THREE.Color(0xffffff)

//Camera
const camera =new THREE.PerspectiveCamera(75, sizes.width/sizes.height,1,1000)
camera.position.set(-9,4,-3)
//scene.add(camera)

//lighting
const directionallight=new THREE.DirectionalLight(0xffffff,1)
directionallight.position.set(-6,5,-1)
directionallight.castShadow=true
// directionallight.shadow.mapSize.width=sizes.width
// directionallight.shadow.mapSize.height=sizes.height

scene.add(directionallight)

const ambientLight=new THREE.AmbientLight(0xffffff,1.5)
scene.add(ambientLight)

//OrbitControls
const controls=new OrbitControls(camera,renderer.domElement)
controls.addEventListener('change',()=> {renderer.render(scene,camera)})
controls.target.set(0,0,0)
controls.update()





// create product


const brown_color=new THREE.Color(0x964b00);
const grey_color = new THREE.Color(0x57554f);
const orange_color = new THREE.Color(0xffaa00);
const red_color = new THREE.Color(0xff0a0a);

const geometry=new THREE.BoxGeometry(.5,.5,.5)

const material=new THREE.MeshStandardMaterial({color: grey_color})

const mmi = new MouseMeshInteraction(scene, camera);

const realboxMesh5=new THREE.Mesh(geometry,material)
realboxMesh5.position.set(-7.5,3.6,-1.45)
realboxMesh5.name='box';
scene.add(realboxMesh5)

//mouse mesh interactions


mmi.addHandler('box', 'mouseenter', function(mesh) {
	console.log('mouse is over the mesh!  ', mesh);
	mesh.material.color = orange_color;
});

mmi.addHandler('box', 'mouseleave', function(mesh) {
	console.log('mouse has left!  ', mesh);
	mesh.material.color = gray_color;
});

mmi.addHandler('box', 'mousedown', function(mesh) {
	console.log('mouse button is pressing on the mesh!  ', mesh);
	mesh.material.color = red_color;
});

mmi.addHandler('box', 'mouseup', function(mesh) {
	console.log('mouse button is released on the mesh!  ', mesh);
	mesh.material.color = orange_color;
});

mmi.addHandler('box', 'click', function(mesh) {
	console.log('mouse button is clicked on the mesh!  ', mesh);
});

//load the model
const loader =new GLTFLoader()
loader.load('project.glb-1.glb', function(glb){
  console.log(glb)
  const model=glb.scene;
  model.position.set(-6,3,-2)
  model.scale.set(.285,.285,.285)
  scene.add(model)
},function(xhr){
  console.log((xhr.loaded/xhr.total*100) +"%loaded")
},function(error){
  console.log('An error occured')
  

})



//render 3D model
function animateModel(){
  requestAnimationFrame(animateModel)
  mmi.update();
  renderer.render(scene,camera)
}
animateModel()

var stage1 = document.getElementById("stage1");
stage1.addEventListener("click" , function() {
    animateBoxStage1(-5);
});
var stage2 = document.getElementById("stage2");
stage2.addEventListener("click", animateBoxStage2);

var stage3 = document.getElementById("stage3");
stage3.addEventListener("click", animateBoxStage3);

var stage4 = document.getElementById("stage4");
stage4.addEventListener("click", animateBoxStage4);

function animateBoxStage1() {
    let myReq=requestAnimationFrame(animateBoxStage1)
    
    if ( realboxMesh5.position.x < -5 ) {
        realboxMesh5.position.set(realboxMesh5.position.x+.01,3.6,-1.45)
    } else { 
      realboxMesh5.position.set(-5,3.6,-1.45);
      setValue(stage1Res,stage1value,temp)
      cancelAnimationFrame(myReq); 
    }
    renderer.render(scene,camera)
    console.log(realboxMesh5.position.x)
        
    }

function animateBoxStage2()
{
    let myReq=requestAnimationFrame(animateBoxStage2)
    
    if ( realboxMesh5.position.x < -3.7 ) {
        realboxMesh5.position.set(realboxMesh5.position.x+.01,3.6,-1.45)
    } else { 
      realboxMesh5.position.set(-3.7,3.6,-1.45);
      setValue(stage2Res,stage2value,weight)
      cancelAnimationFrame(myReq); 
    }
    renderer.render(scene,camera)
    console.log(realboxMesh5.position.x)
}

function animateBoxStage3()
{
    let myReq=requestAnimationFrame(animateBoxStage3)
    
    if ( realboxMesh5.position.x < -1.5 ) {
        realboxMesh5.position.set(realboxMesh5.position.x+.01,3.6,-1.45)
    } else { 
     realboxMesh5.position.set(-1.5,3.6,-1.45);
     setValue(stage3Res,stage3value,quality)
      cancelAnimationFrame(myReq); 
    }
    renderer.render(scene,camera)
    console.log(realboxMesh5.position.x)

}
function animateBoxStage4()
{
    let myReq=requestAnimationFrame(animateBoxStage4)
    
    if ( realboxMesh5.position.x < .5 ) {
        realboxMesh5.position.set(realboxMesh5.position.x+.01,3.6,-1.45)
    } else { 
      realboxMesh5.position.set(.5,3.6,-1.45);
      realboxMesh5.material.color=brown_color;
      setValue(stage4Res,stage4value,dimentions)
      cancelAnimationFrame(myReq); 
    }
    renderer.render(scene,camera)
    console.log(realboxMesh5.position.x)

}




<!-- three_mmi.js -->
/*
	Github: https://github.com/danielblagy/three_mmi
	
	MIT License

	Copyright (c) 2022 danielblagy
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
	
	You can find an example project in the github repository (https://github.com/danielblagy/three_mmi) under folder
	named 'example'.
	
	UPDATES:
	1/19/2021: added support for the following even types: mouseenter, mouseleave, mousedown, mouseup
	1/20/2021: fixed bug: mouseleave event wouldn't trigger if there was mouseenter for
							another mesh with the same name property
								(mistake in if condition, due to the utility using the mesh names)
			   added xylophone simulation example project
	9/25/2021: changed local variable 'event' to 'e' in function handleEvent(e), as is logically proper,
				and 'event' being deprecated
	4/9/2022:  updated license
	4/20/2022: fixed the grouping bug (when if meshes were in a group, mouse interactions wouldn't be registered by three_mmi)
	
	USAGE:
	// pass threejs scene and camera
	const mmi = new MouseMeshInteraction(scene, camera);
	
	// create an interactable mesh
	const mesh = new THREE.Mesh(geometry, material);
	// specify a name for the mesh (needed for mmi to work, you can give the same name to multiple meshes)
	mesh.name = 'my_interactable_mesh';
	scene.add(mesh);
	
	// there are 7 types of interactions available:
	//		* 'click' 		(left mouse button click)
	//		* 'dblclick' 	(left mouse button double click)
	//		* 'contextmenu' (right mouse button click, triggered before opening the context menu)
	//		* 'mouseenter' 	(mouse cursor is moved onto the element that has the listener attached)
	//		* 'mouseleave' 	(mouse cursor is moved off the element that has the listener attached)
	//		* 'mousedown' 	(mouse button is pressed on an element)
	//		* 'mouseup' 	(mouse button is released over an element)
	
	// create a handler for when user clicks on the mesh with name 'my_interactable_mesh'
	mmi.addHandler('my_interactable_mesh', 'click', function(mesh) {
		console.log('interactable mesh has been clicked!');
		console.log(mesh);
	});
	
	// put mmi.update() inside the graphics update function
	function animate() {
		requestAnimationFrame( animate );
		
		mmi.update();
		
		renderer.render( scene, camera );
	}
	animate();
	
	QUICKSTART TEMPLATE:
	
	import * as THREE from 'three'
	import MouseMeshInteraction from 'three_mmi'
	
	const scene = new THREE.Scene();
				
	const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
	camera.position.set(0, 0, 50);
			
	const renderer = new THREE.WebGLRenderer({antialias : true});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0xe0b2a4, 1.0);
	document.body.appendChild(renderer.domElement);
	
	// create an interactable light buld mesh
	
	const gray_color = new THREE.Color(0x57554f);
	const yellow_color = new THREE.Color(0xe0c53a);
	
	const bulb_geometry = new THREE.BoxGeometry(5, 5, 5);
	
	const bulb_material = new THREE.MeshBasicMaterial( { color: yellow_color } );
	
	var bulb_mesh = new THREE.Mesh(bulb_geometry, bulb_material);
	// add a name to the mesh (needed for mmi to work, you can give the same name to multiple meshes)
	bulb_mesh.name = 'bulb';
	bulb_mesh.position.set(0, 0, 0);
	scene.add(bulb_mesh);
	
	// initialize instance of class MouseMeshInteraction, passing threejs scene and camera
	const mmi = new MouseMeshInteraction(scene, camera);
	
	// add a handler on mouse click for mesh (or meshes) with the name 'bulb'
	mmi.addHandler('bulb', 'click', function(mesh) {
		console.log('bulb mesh is being clicked!');
		// switch between colors
		if (mesh.material.color === gray_color) {
			mesh.material.color = yellow_color;
		}
		else {
			mesh.material.color = gray_color;
		}
	});
	
	// just to test if the new features are conflicting with previously supported events
	//		(everything seems to be OK)
	mmi.addHandler('bulb', 'dblclick', function(mesh) {
		console.log('bulb mesh is double clicked!');
	});
	mmi.addHandler('bulb', 'contextmenu', function(mesh) {
		console.log('bulb mesh is pressed with the right button!');
	});
	
	const green_color = new THREE.Color(0x00bb00);
	const orange_color = new THREE.Color(0xffaa00);
	const red_color = new THREE.Color(0xff0a0a);
	const test_mesh_geometry = new THREE.BoxGeometry( 5, 5, 5 ); 
	const test_mesh_material = new THREE.MeshBasicMaterial( { color: green_color } );
	var test_mesh = new THREE.Mesh(test_mesh_geometry, test_mesh_material);
	test_mesh.name = 'new_features_mesh';
	test_mesh.position.set(10, 0, 10);
	scene.add(test_mesh);
			
	mmi.addHandler('new_features_mesh', 'mouseenter', function(mesh) {
		console.log('mouse is over the mesh!  ', mesh);
		mesh.material.color = orange_color;
	});
	
	mmi.addHandler('new_features_mesh', 'mouseleave', function(mesh) {
		console.log('mouse has left!  ', mesh);
		mesh.material.color = green_color;
	});
	
	mmi.addHandler('new_features_mesh', 'mousedown', function(mesh) {
		console.log('mouse button is pressing on the mesh!  ', mesh);
		mesh.material.color = red_color;
	});
	
	mmi.addHandler('new_features_mesh', 'mouseup', function(mesh) {
		console.log('mouse button is released on the mesh!  ', mesh);
		mesh.material.color = orange_color;
	});
	
	mmi.addHandler('new_features_mesh', 'click', function(mesh) {
		console.log('mouse button is clicked on the mesh!  ', mesh);
	});
	
	function render() {
		requestAnimationFrame(render);
		// update the mmi
		mmi.update();
		renderer.render(scene, camera);
	}
	
	render();
*/

import * as THREE from 'three'

const canvas =document.querySelector(".webgl")

//set sizes
     const sizes={
        width : canvas.width,
        height : canvas.height
        }

class MouseMeshInteractionHandler {
	constructor(mesh_name, handler_function) {
		this.mesh_name = mesh_name;
		this.handler_function = handler_function;
	}
}

class MouseMeshInteraction {
	
	constructor(scene, camera) {
		this.scene = scene;
		this.camera = camera;
		
		this.raycaster = new THREE.Raycaster();
		this.mouse = new THREE.Vector2();
		
		this.updated = false;
		this.event = '';
		
		// last mesh that the mouse cursor was over
		this.last_mouseenter_mesh = undefined;
		// last mesh that the mouse was pressing down
		this.last_pressed_mesh = undefined;
		
		this.handlers = new Map();
		
		this.handlers.set('click', []);
		this.handlers.set('dblclick', []);
		this.handlers.set('contextmenu', []);
		
		this.handlers.set('mousedown', []);
		this.handlers.set('mouseup', []);
		this.handlers.set('mouseenter', []);
		this.handlers.set('mouseleave', []);
		
		window.addEventListener('mousemove', this);
		
		window.addEventListener('click', this);
		window.addEventListener('dblclick', this);
		window.addEventListener('contextmenu', this);
		
		window.addEventListener('mousedown', this);
	}
	
	handleEvent(e) {
		switch(e.type) {
			case "mousemove": {
				this.mouse.x = (e.clientX / sizes.width) * 2 - 1;
				this.mouse.y = -(e.clientY / sizes.height) * 2 + 1;
				this.updated = true;
				this.event = 'motion';
			}
			break;
			default: {
				this.updated = true;
				this.event = e.type;
			}
		}
	}
	
	addHandler(mesh_name, event_type, handler_function) {
		if (this.handlers.has(event_type)) {
			this.handlers.get(event_type).push(new MouseMeshInteractionHandler(mesh_name, handler_function));
		}
	}
	
	update() {
		if (this.updated) {
			// update the picking ray with the camera and mouse position
			this.raycaster.setFromCamera(this.mouse, this.camera);
			
			// calculate objects intersecting the picking ray
			const intersects = this.raycaster.intersectObjects(this.scene.children, true);
			
			if (intersects.length > 0) {
				// special test for events: 'mouseenter', 'mouseleave'
				if (this.event === 'motion') {
					let mouseenter_handlers = this.handlers.get('mouseenter');
					let mouseleave_handlers = this.handlers.get('mouseleave');
					
					if (mouseleave_handlers.length > 0) {
						for (const handler of mouseleave_handlers) {
							// if mesh was entered by mouse previously, but not anymore, that means it has been mouseleave'd
							if (
								this.last_mouseenter_mesh !== undefined
								&& intersects[0].object !== this.last_mouseenter_mesh
								&& handler.mesh_name === this.last_mouseenter_mesh.name
							) {
								handler.handler_function(this.last_mouseenter_mesh);
								break;
							}
						}
					}
					
					if (mouseenter_handlers.length > 0) {
						for (const handler of mouseenter_handlers) {
							if (handler.mesh_name === intersects[0].object.name && intersects[0].object !== this.last_mouseenter_mesh) {
								this.last_mouseenter_mesh = intersects[0].object;
								handler.handler_function(intersects[0].object);
								break;
							}
						}
					}
				}
				else {
					// if mouseup event has occurred
					if (this.event === 'click' && this.last_pressed_mesh === intersects[0].object) {
						for (const handler of this.handlers.get('mouseup')) {
							if (handler.mesh_name === intersects[0].object.name) {
								handler.handler_function(intersects[0].object);
								break;
							}
						}
						this.last_pressed_mesh = undefined;
					}
					
					// for mouseup event handler to work
					if (this.event === 'mousedown') {
						this.last_pressed_mesh = intersects[0].object;
					}
					
					let handlers_of_event = this.handlers.get(this.event);
					for (const handler of handlers_of_event) {
						if (handler.mesh_name === intersects[0].object.name) {
							handler.handler_function(intersects[0].object);
							break;
						}
					}
				}
			}
			// if mouse doesn't intersect any meshes
			else if (this.event === 'motion') {
				// special test for 'mouseleave' event
				// 			(since it may be triggered when cursor doesn't intersect with any meshes)
				for (const handler of this.handlers.get('mouseleave')) {
					// if mesh was entered by mouse previously, but not anymore, that means it has been mouseleave'd
					if (this.last_mouseenter_mesh !== undefined && handler.mesh_name === this.last_mouseenter_mesh.name) {
						handler.handler_function(this.last_mouseenter_mesh);
						this.last_mouseenter_mesh = undefined;
						break;
					}
				}
			}
			
			this.updated = false;
		}
	}
}

export default MouseMeshInteraction;

<!-- logic.js -->

//var ID,temp,weight,quality,dimentions,stage1value,stage2value,stage3value,stage4value
var check = document.getElementById("submitFields");
check.addEventListener("click", submitFields);
function submitFields() {
    // Code to handle the submitted fields
     ID = document.getElementById('ProductID').value;
     temp = document.getElementById('Temperature').value;
     weight = document.getElementById('Weight').value;
     quality = document.getElementById('Quality').value;
     dimentions = document.getElementById('Dimentions').value;
       stage1value = document.getElementById('stage1value').value
       stage2value = document.getElementById('stage2value').value
       stage3value =document.getElementById('stage3value').value
       stage4value =document.getElementById('stage4value').value

       //setValue(stage1value,temp)
   
    // Do something with the field values
    // ...
    console.log(ID,temp,weight,quality,dimentions)
  console.log(stage1value,stage2value,stage3value,stage4value)
  }
  
  function setValue(field,stagevalue,product) {

    if(stagevalue>product){
    
    field.value = "Pass";

    }else{
       changeInputClass(field)
      field.value="Fail"
    }
  }

  function changeInputClass(field) {
   //var stage1Res = document.getElementById("stage1Res");
   field.classList.remove("btn-outline-success");
   field.classList.add("btn-outline-danger");
}





 